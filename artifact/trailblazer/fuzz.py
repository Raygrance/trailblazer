import schemathesis
# from hypothesis import settings, Phase
# from schemathesis.checks import not_a_server_error, status_code_conformance, content_type_conformance, response_schema_conformance, negative_data_rejection, response_headers_conformance
from hypothesis import settings
from schemathesis.checks import not_a_server_error
from schemathesis.specs.openapi.checks import negative_data_rejection

from baseline import replay_traffic

import json
from schemathesis import Case
from typing import List
import pickle

import path
import mutate
import random
import pytest
import requests
import time
from reqobj import RequestObject


authentication_headers = {}
BASE_URL = ""
MUTATE_PERCENT = 0.5

def load_spec(target):
    filename = (target+":")[:target.find(":")]  # this removes the port number from the target
    f = open("tests/" + filename + ".json", "r", encoding="utf-8")
    custom_schema_dict = json.load(f)
    f.close()


    allowed_methods = {"get", "post", "put", "delete", "patch", "parameters"}
    if "paths" in custom_schema_dict:
        for p in custom_schema_dict["paths"].values():
            # Identify keys that are NOT in the allowed list
            to_remove = [k for k in p.keys() if k.lower() not in allowed_methods]
            # Remove them
            for k in to_remove:
                del p[k]


    # Define the base URL for the API
    global BASE_URL
    BASE_URL = custom_schema_dict["servers"][0]["url"]

    # schema = schemathesis.from_dict(custom_schema_dict, base_url=BASE_URL)
    schema = schemathesis.openapi.from_dict(custom_schema_dict)

    with open("tests/" + filename + ".pkl", "rb") as file:
        ReqObjs = pickle.load(file)

    return schema, ReqObjs, custom_schema_dict

def parse_headers(headers):
    '''
    headers: str
        The headers to be used in the requests
    '''
    result = {}
    if headers:
        for h in headers:
            key, value = h.split(":", 1)
            result[key.strip()] = value.strip()
    return result

def run_fuzz(target, n, m, r, headers=None):
    '''
    target: str
        The target web application to be tested
    n: int
        Max number of payload to be generated by Schemathesis, per endpoint
    m: bool
        Enable Trailblazer's mutation engine, to replace half of payloads generated by Schemathesis
    r: bool
        Replay captured traffic from host
    headers: array of str
        The headers to be used in the requests
    '''
    # replay traffic captured according to stored data
    if r:
        print(f"Replaying captured traffic for host {target} using payloads generated from ReqObjs...")
        schema, ReqObjs, schema_dict = load_spec(target)
        headers_dict = parse_headers(headers)
        t0 = time.time()
        count = 0

        for (rule, method), reqobj_list in ReqObjs.items():
            reqobj = reqobj_list[0]
            for _ in range(max(1, len(reqobj.examples))): # num captured requests for this endpoint

                path_str = path.rule_to_path(rule)

                seed_id = random.choice(reqobj.seed_ids) if reqobj.seed_ids else None
                payload = reqobj.generate(seed_id=seed_id) # generate a payload according to ReqObj grammar
                # send request
                try:
                    response = send_request(
                        base_url=BASE_URL,
                        method=method,
                        path=path_str,
                        body=payload,
                        headers=headers_dict)
                    print(f"Sent {method.upper()} request to {BASE_URL}{path_str} with seed ID {seed_id}. Payload: {payload}, Response Code: {response.status_code}")
                except Exception as e:
                    print(f"Failed to send request: {e}")
                count += 1

        t1 = time.time()
        print(f"Finished {count} requests in {t1 - t0} seconds")
    # Fuzz test target using Schemathesis
    # Optionally use mutation engine
    else:
        schema, ReqObjs, schema_dict = load_spec(target)
        global authentication_headers 
        authentication_headers = parse_headers(headers)
        schema.headers = authentication_headers # for some reason, this doesn't work. so we have to set the headers again in the test_api function

        # the below two blocks of commented code were added to filter out TRACE methods, 
        # but they do not work as intended
        @schemathesis.hook
        def after_call(context, case, response):
            if response.status_code == 501:
                print("501 Not Implemented detected!")
                response.status_code = 200  # Treat 501 as a non-error for APIs that do not implement certain methods

        @schemathesis.hook
        def map_body(context, body):
            # Access the generated payload (case.body or case.path_parameters, etc.)
            # body = mutate.mutate(body)
            # print(context.operation.definition.raw)
            if "requestBody" not in context.operation.definition.raw:
                return body
            
            random.seed()
            if random.random() > MUTATE_PERCENT * m:  # if m is True, 50% of the chance mutate the body
                return body  # when m is False, return the original body
            for rule, method in ReqObjs:
                if context.operation.path == path.rule_to_path(rule) and \
                    context.operation.method == method:
                    
                    # pass the grammar for current endpoint to mutation engine
                    endpoint_schema = schema_dict["paths"][context.operation.path][method]["requestBody"]["content"]["application/json"]["schema"]
                    body = mutate.get_mutation(ReqObjs[(rule, method)][0], endpoint_schema)
                    print("--------------------")
                    #case = Case(operation=context.operation, generation_time=1e-6, body=payload)
                    #case.call_and_validate(checks=(not_a_server_error,negative_data_rejection))
                    #examples.append(Case(operation=context.operation, generation_time=1e-6, body=payload))
                    return body
            return body
            
        test_api_decorated = settings(max_examples=n)(schema.parametrize()(test_api))
        pytest.main(["-v", __file__])


# Define a test function using the custom schema
# @schema.parametrize()
# @settings(max_examples=n)
def test_api(case):
    case.headers={"Authorization": "Bearer 2bHv1-Bt_QfMeZxs-CDtVSNSZLyNARj6"} # authentication_headers # set the authentication headers for the request
    # Make a request to the API based on the generated test case
    if case.path_parameters and "id1" in case.path_parameters:
        if random.random() < 0.2: # 20% of the time, use a pre-defined value for id1
            case.path_parameters["id1"] = "trailblazer001"
    # response = case.call_and_validate(checks=(not_a_server_error,negative_data_rejection))
    response = case.call_and_validate(base_url=BASE_URL, checks=(not_a_server_error, negative_data_rejection))


def send_request(base_url, method, path, body, headers):
    url = base_url.rstrip("/") + path
    response = requests.request(
        method=method.upper(),
        url=url,
        json=body,
        headers=headers,
        timeout=10,
    )
    return response

